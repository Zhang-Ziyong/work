// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map_overlap.proto

#ifndef PROTOBUF_INCLUDED_map_5foverlap_2eproto
#define PROTOBUF_INCLUDED_map_5foverlap_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "map_id.pb.h"
#include "map_geometry.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_map_5foverlap_2eproto 

namespace protobuf_map_5foverlap_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_map_5foverlap_2eproto
namespace cvte {
namespace hdmap {
class ClearAreaOverlapInfo;
class ClearAreaOverlapInfoDefaultTypeInternal;
extern ClearAreaOverlapInfoDefaultTypeInternal _ClearAreaOverlapInfo_default_instance_;
class CrosswalkOverlapInfo;
class CrosswalkOverlapInfoDefaultTypeInternal;
extern CrosswalkOverlapInfoDefaultTypeInternal _CrosswalkOverlapInfo_default_instance_;
class JunctionOverlapInfo;
class JunctionOverlapInfoDefaultTypeInternal;
extern JunctionOverlapInfoDefaultTypeInternal _JunctionOverlapInfo_default_instance_;
class LaneOverlapInfo;
class LaneOverlapInfoDefaultTypeInternal;
extern LaneOverlapInfoDefaultTypeInternal _LaneOverlapInfo_default_instance_;
class ObjectOverlapInfo;
class ObjectOverlapInfoDefaultTypeInternal;
extern ObjectOverlapInfoDefaultTypeInternal _ObjectOverlapInfo_default_instance_;
class Overlap;
class OverlapDefaultTypeInternal;
extern OverlapDefaultTypeInternal _Overlap_default_instance_;
class PNCJunctionOverlapInfo;
class PNCJunctionOverlapInfoDefaultTypeInternal;
extern PNCJunctionOverlapInfoDefaultTypeInternal _PNCJunctionOverlapInfo_default_instance_;
class ParkingSpaceOverlapInfo;
class ParkingSpaceOverlapInfoDefaultTypeInternal;
extern ParkingSpaceOverlapInfoDefaultTypeInternal _ParkingSpaceOverlapInfo_default_instance_;
class RSUOverlapInfo;
class RSUOverlapInfoDefaultTypeInternal;
extern RSUOverlapInfoDefaultTypeInternal _RSUOverlapInfo_default_instance_;
class RegionOverlapInfo;
class RegionOverlapInfoDefaultTypeInternal;
extern RegionOverlapInfoDefaultTypeInternal _RegionOverlapInfo_default_instance_;
class SignalOverlapInfo;
class SignalOverlapInfoDefaultTypeInternal;
extern SignalOverlapInfoDefaultTypeInternal _SignalOverlapInfo_default_instance_;
class SpeedBumpOverlapInfo;
class SpeedBumpOverlapInfoDefaultTypeInternal;
extern SpeedBumpOverlapInfoDefaultTypeInternal _SpeedBumpOverlapInfo_default_instance_;
class StopSignOverlapInfo;
class StopSignOverlapInfoDefaultTypeInternal;
extern StopSignOverlapInfoDefaultTypeInternal _StopSignOverlapInfo_default_instance_;
class YieldOverlapInfo;
class YieldOverlapInfoDefaultTypeInternal;
extern YieldOverlapInfoDefaultTypeInternal _YieldOverlapInfo_default_instance_;
}  // namespace hdmap
}  // namespace cvte
namespace google {
namespace protobuf {
template<> ::cvte::hdmap::ClearAreaOverlapInfo* Arena::CreateMaybeMessage<::cvte::hdmap::ClearAreaOverlapInfo>(Arena*);
template<> ::cvte::hdmap::CrosswalkOverlapInfo* Arena::CreateMaybeMessage<::cvte::hdmap::CrosswalkOverlapInfo>(Arena*);
template<> ::cvte::hdmap::JunctionOverlapInfo* Arena::CreateMaybeMessage<::cvte::hdmap::JunctionOverlapInfo>(Arena*);
template<> ::cvte::hdmap::LaneOverlapInfo* Arena::CreateMaybeMessage<::cvte::hdmap::LaneOverlapInfo>(Arena*);
template<> ::cvte::hdmap::ObjectOverlapInfo* Arena::CreateMaybeMessage<::cvte::hdmap::ObjectOverlapInfo>(Arena*);
template<> ::cvte::hdmap::Overlap* Arena::CreateMaybeMessage<::cvte::hdmap::Overlap>(Arena*);
template<> ::cvte::hdmap::PNCJunctionOverlapInfo* Arena::CreateMaybeMessage<::cvte::hdmap::PNCJunctionOverlapInfo>(Arena*);
template<> ::cvte::hdmap::ParkingSpaceOverlapInfo* Arena::CreateMaybeMessage<::cvte::hdmap::ParkingSpaceOverlapInfo>(Arena*);
template<> ::cvte::hdmap::RSUOverlapInfo* Arena::CreateMaybeMessage<::cvte::hdmap::RSUOverlapInfo>(Arena*);
template<> ::cvte::hdmap::RegionOverlapInfo* Arena::CreateMaybeMessage<::cvte::hdmap::RegionOverlapInfo>(Arena*);
template<> ::cvte::hdmap::SignalOverlapInfo* Arena::CreateMaybeMessage<::cvte::hdmap::SignalOverlapInfo>(Arena*);
template<> ::cvte::hdmap::SpeedBumpOverlapInfo* Arena::CreateMaybeMessage<::cvte::hdmap::SpeedBumpOverlapInfo>(Arena*);
template<> ::cvte::hdmap::StopSignOverlapInfo* Arena::CreateMaybeMessage<::cvte::hdmap::StopSignOverlapInfo>(Arena*);
template<> ::cvte::hdmap::YieldOverlapInfo* Arena::CreateMaybeMessage<::cvte::hdmap::YieldOverlapInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace cvte {
namespace hdmap {

// ===================================================================

class LaneOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.LaneOverlapInfo) */ {
 public:
  LaneOverlapInfo();
  virtual ~LaneOverlapInfo();

  LaneOverlapInfo(const LaneOverlapInfo& from);

  inline LaneOverlapInfo& operator=(const LaneOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneOverlapInfo(LaneOverlapInfo&& from) noexcept
    : LaneOverlapInfo() {
    *this = ::std::move(from);
  }

  inline LaneOverlapInfo& operator=(LaneOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const LaneOverlapInfo*>(
               &_LaneOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LaneOverlapInfo* other);
  friend void swap(LaneOverlapInfo& a, LaneOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneOverlapInfo* New() const final {
    return CreateMaybeMessage<LaneOverlapInfo>(NULL);
  }

  LaneOverlapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneOverlapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneOverlapInfo& from);
  void MergeFrom(const LaneOverlapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cvte.hdmap.Id region_overlap_id = 4;
  bool has_region_overlap_id() const;
  void clear_region_overlap_id();
  static const int kRegionOverlapIdFieldNumber = 4;
  private:
  const ::cvte::hdmap::Id& _internal_region_overlap_id() const;
  public:
  const ::cvte::hdmap::Id& region_overlap_id() const;
  ::cvte::hdmap::Id* release_region_overlap_id();
  ::cvte::hdmap::Id* mutable_region_overlap_id();
  void set_allocated_region_overlap_id(::cvte::hdmap::Id* region_overlap_id);

  // optional double start_s = 1;
  bool has_start_s() const;
  void clear_start_s();
  static const int kStartSFieldNumber = 1;
  double start_s() const;
  void set_start_s(double value);

  // optional double end_s = 2;
  bool has_end_s() const;
  void clear_end_s();
  static const int kEndSFieldNumber = 2;
  double end_s() const;
  void set_end_s(double value);

  // optional bool is_merge = 3;
  bool has_is_merge() const;
  void clear_is_merge();
  static const int kIsMergeFieldNumber = 3;
  bool is_merge() const;
  void set_is_merge(bool value);

  // @@protoc_insertion_point(class_scope:cvte.hdmap.LaneOverlapInfo)
 private:
  void set_has_start_s();
  void clear_has_start_s();
  void set_has_end_s();
  void clear_has_end_s();
  void set_has_is_merge();
  void clear_has_is_merge();
  void set_has_region_overlap_id();
  void clear_has_region_overlap_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::cvte::hdmap::Id* region_overlap_id_;
  double start_s_;
  double end_s_;
  bool is_merge_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignalOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.SignalOverlapInfo) */ {
 public:
  SignalOverlapInfo();
  virtual ~SignalOverlapInfo();

  SignalOverlapInfo(const SignalOverlapInfo& from);

  inline SignalOverlapInfo& operator=(const SignalOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignalOverlapInfo(SignalOverlapInfo&& from) noexcept
    : SignalOverlapInfo() {
    *this = ::std::move(from);
  }

  inline SignalOverlapInfo& operator=(SignalOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const SignalOverlapInfo*>(
               &_SignalOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SignalOverlapInfo* other);
  friend void swap(SignalOverlapInfo& a, SignalOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignalOverlapInfo* New() const final {
    return CreateMaybeMessage<SignalOverlapInfo>(NULL);
  }

  SignalOverlapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SignalOverlapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SignalOverlapInfo& from);
  void MergeFrom(const SignalOverlapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cvte.hdmap.SignalOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StopSignOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.StopSignOverlapInfo) */ {
 public:
  StopSignOverlapInfo();
  virtual ~StopSignOverlapInfo();

  StopSignOverlapInfo(const StopSignOverlapInfo& from);

  inline StopSignOverlapInfo& operator=(const StopSignOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopSignOverlapInfo(StopSignOverlapInfo&& from) noexcept
    : StopSignOverlapInfo() {
    *this = ::std::move(from);
  }

  inline StopSignOverlapInfo& operator=(StopSignOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopSignOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopSignOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const StopSignOverlapInfo*>(
               &_StopSignOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(StopSignOverlapInfo* other);
  friend void swap(StopSignOverlapInfo& a, StopSignOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopSignOverlapInfo* New() const final {
    return CreateMaybeMessage<StopSignOverlapInfo>(NULL);
  }

  StopSignOverlapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StopSignOverlapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StopSignOverlapInfo& from);
  void MergeFrom(const StopSignOverlapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSignOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cvte.hdmap.StopSignOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CrosswalkOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.CrosswalkOverlapInfo) */ {
 public:
  CrosswalkOverlapInfo();
  virtual ~CrosswalkOverlapInfo();

  CrosswalkOverlapInfo(const CrosswalkOverlapInfo& from);

  inline CrosswalkOverlapInfo& operator=(const CrosswalkOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrosswalkOverlapInfo(CrosswalkOverlapInfo&& from) noexcept
    : CrosswalkOverlapInfo() {
    *this = ::std::move(from);
  }

  inline CrosswalkOverlapInfo& operator=(CrosswalkOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrosswalkOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrosswalkOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const CrosswalkOverlapInfo*>(
               &_CrosswalkOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CrosswalkOverlapInfo* other);
  friend void swap(CrosswalkOverlapInfo& a, CrosswalkOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrosswalkOverlapInfo* New() const final {
    return CreateMaybeMessage<CrosswalkOverlapInfo>(NULL);
  }

  CrosswalkOverlapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CrosswalkOverlapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CrosswalkOverlapInfo& from);
  void MergeFrom(const CrosswalkOverlapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrosswalkOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cvte.hdmap.Id region_overlap_id = 1;
  bool has_region_overlap_id() const;
  void clear_region_overlap_id();
  static const int kRegionOverlapIdFieldNumber = 1;
  private:
  const ::cvte::hdmap::Id& _internal_region_overlap_id() const;
  public:
  const ::cvte::hdmap::Id& region_overlap_id() const;
  ::cvte::hdmap::Id* release_region_overlap_id();
  ::cvte::hdmap::Id* mutable_region_overlap_id();
  void set_allocated_region_overlap_id(::cvte::hdmap::Id* region_overlap_id);

  // @@protoc_insertion_point(class_scope:cvte.hdmap.CrosswalkOverlapInfo)
 private:
  void set_has_region_overlap_id();
  void clear_has_region_overlap_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::cvte::hdmap::Id* region_overlap_id_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JunctionOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.JunctionOverlapInfo) */ {
 public:
  JunctionOverlapInfo();
  virtual ~JunctionOverlapInfo();

  JunctionOverlapInfo(const JunctionOverlapInfo& from);

  inline JunctionOverlapInfo& operator=(const JunctionOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JunctionOverlapInfo(JunctionOverlapInfo&& from) noexcept
    : JunctionOverlapInfo() {
    *this = ::std::move(from);
  }

  inline JunctionOverlapInfo& operator=(JunctionOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JunctionOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JunctionOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const JunctionOverlapInfo*>(
               &_JunctionOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(JunctionOverlapInfo* other);
  friend void swap(JunctionOverlapInfo& a, JunctionOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JunctionOverlapInfo* New() const final {
    return CreateMaybeMessage<JunctionOverlapInfo>(NULL);
  }

  JunctionOverlapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JunctionOverlapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JunctionOverlapInfo& from);
  void MergeFrom(const JunctionOverlapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JunctionOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cvte.hdmap.JunctionOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class YieldOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.YieldOverlapInfo) */ {
 public:
  YieldOverlapInfo();
  virtual ~YieldOverlapInfo();

  YieldOverlapInfo(const YieldOverlapInfo& from);

  inline YieldOverlapInfo& operator=(const YieldOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  YieldOverlapInfo(YieldOverlapInfo&& from) noexcept
    : YieldOverlapInfo() {
    *this = ::std::move(from);
  }

  inline YieldOverlapInfo& operator=(YieldOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YieldOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const YieldOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const YieldOverlapInfo*>(
               &_YieldOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(YieldOverlapInfo* other);
  friend void swap(YieldOverlapInfo& a, YieldOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline YieldOverlapInfo* New() const final {
    return CreateMaybeMessage<YieldOverlapInfo>(NULL);
  }

  YieldOverlapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<YieldOverlapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const YieldOverlapInfo& from);
  void MergeFrom(const YieldOverlapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(YieldOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cvte.hdmap.YieldOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClearAreaOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.ClearAreaOverlapInfo) */ {
 public:
  ClearAreaOverlapInfo();
  virtual ~ClearAreaOverlapInfo();

  ClearAreaOverlapInfo(const ClearAreaOverlapInfo& from);

  inline ClearAreaOverlapInfo& operator=(const ClearAreaOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClearAreaOverlapInfo(ClearAreaOverlapInfo&& from) noexcept
    : ClearAreaOverlapInfo() {
    *this = ::std::move(from);
  }

  inline ClearAreaOverlapInfo& operator=(ClearAreaOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClearAreaOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClearAreaOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const ClearAreaOverlapInfo*>(
               &_ClearAreaOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ClearAreaOverlapInfo* other);
  friend void swap(ClearAreaOverlapInfo& a, ClearAreaOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClearAreaOverlapInfo* New() const final {
    return CreateMaybeMessage<ClearAreaOverlapInfo>(NULL);
  }

  ClearAreaOverlapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClearAreaOverlapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClearAreaOverlapInfo& from);
  void MergeFrom(const ClearAreaOverlapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearAreaOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cvte.hdmap.ClearAreaOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpeedBumpOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.SpeedBumpOverlapInfo) */ {
 public:
  SpeedBumpOverlapInfo();
  virtual ~SpeedBumpOverlapInfo();

  SpeedBumpOverlapInfo(const SpeedBumpOverlapInfo& from);

  inline SpeedBumpOverlapInfo& operator=(const SpeedBumpOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeedBumpOverlapInfo(SpeedBumpOverlapInfo&& from) noexcept
    : SpeedBumpOverlapInfo() {
    *this = ::std::move(from);
  }

  inline SpeedBumpOverlapInfo& operator=(SpeedBumpOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedBumpOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedBumpOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const SpeedBumpOverlapInfo*>(
               &_SpeedBumpOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SpeedBumpOverlapInfo* other);
  friend void swap(SpeedBumpOverlapInfo& a, SpeedBumpOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeedBumpOverlapInfo* New() const final {
    return CreateMaybeMessage<SpeedBumpOverlapInfo>(NULL);
  }

  SpeedBumpOverlapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpeedBumpOverlapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpeedBumpOverlapInfo& from);
  void MergeFrom(const SpeedBumpOverlapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedBumpOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cvte.hdmap.SpeedBumpOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParkingSpaceOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.ParkingSpaceOverlapInfo) */ {
 public:
  ParkingSpaceOverlapInfo();
  virtual ~ParkingSpaceOverlapInfo();

  ParkingSpaceOverlapInfo(const ParkingSpaceOverlapInfo& from);

  inline ParkingSpaceOverlapInfo& operator=(const ParkingSpaceOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkingSpaceOverlapInfo(ParkingSpaceOverlapInfo&& from) noexcept
    : ParkingSpaceOverlapInfo() {
    *this = ::std::move(from);
  }

  inline ParkingSpaceOverlapInfo& operator=(ParkingSpaceOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSpaceOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingSpaceOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const ParkingSpaceOverlapInfo*>(
               &_ParkingSpaceOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ParkingSpaceOverlapInfo* other);
  friend void swap(ParkingSpaceOverlapInfo& a, ParkingSpaceOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkingSpaceOverlapInfo* New() const final {
    return CreateMaybeMessage<ParkingSpaceOverlapInfo>(NULL);
  }

  ParkingSpaceOverlapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ParkingSpaceOverlapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ParkingSpaceOverlapInfo& from);
  void MergeFrom(const ParkingSpaceOverlapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParkingSpaceOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cvte.hdmap.ParkingSpaceOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PNCJunctionOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.PNCJunctionOverlapInfo) */ {
 public:
  PNCJunctionOverlapInfo();
  virtual ~PNCJunctionOverlapInfo();

  PNCJunctionOverlapInfo(const PNCJunctionOverlapInfo& from);

  inline PNCJunctionOverlapInfo& operator=(const PNCJunctionOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PNCJunctionOverlapInfo(PNCJunctionOverlapInfo&& from) noexcept
    : PNCJunctionOverlapInfo() {
    *this = ::std::move(from);
  }

  inline PNCJunctionOverlapInfo& operator=(PNCJunctionOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PNCJunctionOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PNCJunctionOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const PNCJunctionOverlapInfo*>(
               &_PNCJunctionOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(PNCJunctionOverlapInfo* other);
  friend void swap(PNCJunctionOverlapInfo& a, PNCJunctionOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PNCJunctionOverlapInfo* New() const final {
    return CreateMaybeMessage<PNCJunctionOverlapInfo>(NULL);
  }

  PNCJunctionOverlapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PNCJunctionOverlapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PNCJunctionOverlapInfo& from);
  void MergeFrom(const PNCJunctionOverlapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PNCJunctionOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cvte.hdmap.PNCJunctionOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RSUOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.RSUOverlapInfo) */ {
 public:
  RSUOverlapInfo();
  virtual ~RSUOverlapInfo();

  RSUOverlapInfo(const RSUOverlapInfo& from);

  inline RSUOverlapInfo& operator=(const RSUOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RSUOverlapInfo(RSUOverlapInfo&& from) noexcept
    : RSUOverlapInfo() {
    *this = ::std::move(from);
  }

  inline RSUOverlapInfo& operator=(RSUOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSUOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RSUOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const RSUOverlapInfo*>(
               &_RSUOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(RSUOverlapInfo* other);
  friend void swap(RSUOverlapInfo& a, RSUOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RSUOverlapInfo* New() const final {
    return CreateMaybeMessage<RSUOverlapInfo>(NULL);
  }

  RSUOverlapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RSUOverlapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RSUOverlapInfo& from);
  void MergeFrom(const RSUOverlapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSUOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cvte.hdmap.RSUOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegionOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.RegionOverlapInfo) */ {
 public:
  RegionOverlapInfo();
  virtual ~RegionOverlapInfo();

  RegionOverlapInfo(const RegionOverlapInfo& from);

  inline RegionOverlapInfo& operator=(const RegionOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegionOverlapInfo(RegionOverlapInfo&& from) noexcept
    : RegionOverlapInfo() {
    *this = ::std::move(from);
  }

  inline RegionOverlapInfo& operator=(RegionOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const RegionOverlapInfo*>(
               &_RegionOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(RegionOverlapInfo* other);
  friend void swap(RegionOverlapInfo& a, RegionOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegionOverlapInfo* New() const final {
    return CreateMaybeMessage<RegionOverlapInfo>(NULL);
  }

  RegionOverlapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegionOverlapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegionOverlapInfo& from);
  void MergeFrom(const RegionOverlapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cvte.hdmap.Polygon polygon = 2;
  int polygon_size() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 2;
  ::cvte::hdmap::Polygon* mutable_polygon(int index);
  ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::Polygon >*
      mutable_polygon();
  const ::cvte::hdmap::Polygon& polygon(int index) const;
  ::cvte::hdmap::Polygon* add_polygon();
  const ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::Polygon >&
      polygon() const;

  // optional .cvte.hdmap.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  private:
  const ::cvte::hdmap::Id& _internal_id() const;
  public:
  const ::cvte::hdmap::Id& id() const;
  ::cvte::hdmap::Id* release_id();
  ::cvte::hdmap::Id* mutable_id();
  void set_allocated_id(::cvte::hdmap::Id* id);

  // @@protoc_insertion_point(class_scope:cvte.hdmap.RegionOverlapInfo)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::Polygon > polygon_;
  ::cvte::hdmap::Id* id_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObjectOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.ObjectOverlapInfo) */ {
 public:
  ObjectOverlapInfo();
  virtual ~ObjectOverlapInfo();

  ObjectOverlapInfo(const ObjectOverlapInfo& from);

  inline ObjectOverlapInfo& operator=(const ObjectOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectOverlapInfo(ObjectOverlapInfo&& from) noexcept
    : ObjectOverlapInfo() {
    *this = ::std::move(from);
  }

  inline ObjectOverlapInfo& operator=(ObjectOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectOverlapInfo& default_instance();

  enum OverlapInfoCase {
    kLaneOverlapInfo = 3,
    kSignalOverlapInfo = 4,
    kStopSignOverlapInfo = 5,
    kCrosswalkOverlapInfo = 6,
    kJunctionOverlapInfo = 7,
    kYieldSignOverlapInfo = 8,
    kClearAreaOverlapInfo = 9,
    kSpeedBumpOverlapInfo = 10,
    kParkingSpaceOverlapInfo = 11,
    kPncJunctionOverlapInfo = 12,
    kRsuOverlapInfo = 13,
    OVERLAP_INFO_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const ObjectOverlapInfo*>(
               &_ObjectOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ObjectOverlapInfo* other);
  friend void swap(ObjectOverlapInfo& a, ObjectOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectOverlapInfo* New() const final {
    return CreateMaybeMessage<ObjectOverlapInfo>(NULL);
  }

  ObjectOverlapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectOverlapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectOverlapInfo& from);
  void MergeFrom(const ObjectOverlapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cvte.hdmap.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  private:
  const ::cvte::hdmap::Id& _internal_id() const;
  public:
  const ::cvte::hdmap::Id& id() const;
  ::cvte::hdmap::Id* release_id();
  ::cvte::hdmap::Id* mutable_id();
  void set_allocated_id(::cvte::hdmap::Id* id);

  // optional .cvte.hdmap.LaneOverlapInfo lane_overlap_info = 3;
  bool has_lane_overlap_info() const;
  void clear_lane_overlap_info();
  static const int kLaneOverlapInfoFieldNumber = 3;
  private:
  const ::cvte::hdmap::LaneOverlapInfo& _internal_lane_overlap_info() const;
  public:
  const ::cvte::hdmap::LaneOverlapInfo& lane_overlap_info() const;
  ::cvte::hdmap::LaneOverlapInfo* release_lane_overlap_info();
  ::cvte::hdmap::LaneOverlapInfo* mutable_lane_overlap_info();
  void set_allocated_lane_overlap_info(::cvte::hdmap::LaneOverlapInfo* lane_overlap_info);

  // optional .cvte.hdmap.SignalOverlapInfo signal_overlap_info = 4;
  bool has_signal_overlap_info() const;
  void clear_signal_overlap_info();
  static const int kSignalOverlapInfoFieldNumber = 4;
  private:
  const ::cvte::hdmap::SignalOverlapInfo& _internal_signal_overlap_info() const;
  public:
  const ::cvte::hdmap::SignalOverlapInfo& signal_overlap_info() const;
  ::cvte::hdmap::SignalOverlapInfo* release_signal_overlap_info();
  ::cvte::hdmap::SignalOverlapInfo* mutable_signal_overlap_info();
  void set_allocated_signal_overlap_info(::cvte::hdmap::SignalOverlapInfo* signal_overlap_info);

  // optional .cvte.hdmap.StopSignOverlapInfo stop_sign_overlap_info = 5;
  bool has_stop_sign_overlap_info() const;
  void clear_stop_sign_overlap_info();
  static const int kStopSignOverlapInfoFieldNumber = 5;
  private:
  const ::cvte::hdmap::StopSignOverlapInfo& _internal_stop_sign_overlap_info() const;
  public:
  const ::cvte::hdmap::StopSignOverlapInfo& stop_sign_overlap_info() const;
  ::cvte::hdmap::StopSignOverlapInfo* release_stop_sign_overlap_info();
  ::cvte::hdmap::StopSignOverlapInfo* mutable_stop_sign_overlap_info();
  void set_allocated_stop_sign_overlap_info(::cvte::hdmap::StopSignOverlapInfo* stop_sign_overlap_info);

  // optional .cvte.hdmap.CrosswalkOverlapInfo crosswalk_overlap_info = 6;
  bool has_crosswalk_overlap_info() const;
  void clear_crosswalk_overlap_info();
  static const int kCrosswalkOverlapInfoFieldNumber = 6;
  private:
  const ::cvte::hdmap::CrosswalkOverlapInfo& _internal_crosswalk_overlap_info() const;
  public:
  const ::cvte::hdmap::CrosswalkOverlapInfo& crosswalk_overlap_info() const;
  ::cvte::hdmap::CrosswalkOverlapInfo* release_crosswalk_overlap_info();
  ::cvte::hdmap::CrosswalkOverlapInfo* mutable_crosswalk_overlap_info();
  void set_allocated_crosswalk_overlap_info(::cvte::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info);

  // optional .cvte.hdmap.JunctionOverlapInfo junction_overlap_info = 7;
  bool has_junction_overlap_info() const;
  void clear_junction_overlap_info();
  static const int kJunctionOverlapInfoFieldNumber = 7;
  private:
  const ::cvte::hdmap::JunctionOverlapInfo& _internal_junction_overlap_info() const;
  public:
  const ::cvte::hdmap::JunctionOverlapInfo& junction_overlap_info() const;
  ::cvte::hdmap::JunctionOverlapInfo* release_junction_overlap_info();
  ::cvte::hdmap::JunctionOverlapInfo* mutable_junction_overlap_info();
  void set_allocated_junction_overlap_info(::cvte::hdmap::JunctionOverlapInfo* junction_overlap_info);

  // optional .cvte.hdmap.YieldOverlapInfo yield_sign_overlap_info = 8;
  bool has_yield_sign_overlap_info() const;
  void clear_yield_sign_overlap_info();
  static const int kYieldSignOverlapInfoFieldNumber = 8;
  private:
  const ::cvte::hdmap::YieldOverlapInfo& _internal_yield_sign_overlap_info() const;
  public:
  const ::cvte::hdmap::YieldOverlapInfo& yield_sign_overlap_info() const;
  ::cvte::hdmap::YieldOverlapInfo* release_yield_sign_overlap_info();
  ::cvte::hdmap::YieldOverlapInfo* mutable_yield_sign_overlap_info();
  void set_allocated_yield_sign_overlap_info(::cvte::hdmap::YieldOverlapInfo* yield_sign_overlap_info);

  // optional .cvte.hdmap.ClearAreaOverlapInfo clear_area_overlap_info = 9;
  bool has_clear_area_overlap_info() const;
  void clear_clear_area_overlap_info();
  static const int kClearAreaOverlapInfoFieldNumber = 9;
  private:
  const ::cvte::hdmap::ClearAreaOverlapInfo& _internal_clear_area_overlap_info() const;
  public:
  const ::cvte::hdmap::ClearAreaOverlapInfo& clear_area_overlap_info() const;
  ::cvte::hdmap::ClearAreaOverlapInfo* release_clear_area_overlap_info();
  ::cvte::hdmap::ClearAreaOverlapInfo* mutable_clear_area_overlap_info();
  void set_allocated_clear_area_overlap_info(::cvte::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info);

  // optional .cvte.hdmap.SpeedBumpOverlapInfo speed_bump_overlap_info = 10;
  bool has_speed_bump_overlap_info() const;
  void clear_speed_bump_overlap_info();
  static const int kSpeedBumpOverlapInfoFieldNumber = 10;
  private:
  const ::cvte::hdmap::SpeedBumpOverlapInfo& _internal_speed_bump_overlap_info() const;
  public:
  const ::cvte::hdmap::SpeedBumpOverlapInfo& speed_bump_overlap_info() const;
  ::cvte::hdmap::SpeedBumpOverlapInfo* release_speed_bump_overlap_info();
  ::cvte::hdmap::SpeedBumpOverlapInfo* mutable_speed_bump_overlap_info();
  void set_allocated_speed_bump_overlap_info(::cvte::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info);

  // optional .cvte.hdmap.ParkingSpaceOverlapInfo parking_space_overlap_info = 11;
  bool has_parking_space_overlap_info() const;
  void clear_parking_space_overlap_info();
  static const int kParkingSpaceOverlapInfoFieldNumber = 11;
  private:
  const ::cvte::hdmap::ParkingSpaceOverlapInfo& _internal_parking_space_overlap_info() const;
  public:
  const ::cvte::hdmap::ParkingSpaceOverlapInfo& parking_space_overlap_info() const;
  ::cvte::hdmap::ParkingSpaceOverlapInfo* release_parking_space_overlap_info();
  ::cvte::hdmap::ParkingSpaceOverlapInfo* mutable_parking_space_overlap_info();
  void set_allocated_parking_space_overlap_info(::cvte::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info);

  // optional .cvte.hdmap.PNCJunctionOverlapInfo pnc_junction_overlap_info = 12;
  bool has_pnc_junction_overlap_info() const;
  void clear_pnc_junction_overlap_info();
  static const int kPncJunctionOverlapInfoFieldNumber = 12;
  private:
  const ::cvte::hdmap::PNCJunctionOverlapInfo& _internal_pnc_junction_overlap_info() const;
  public:
  const ::cvte::hdmap::PNCJunctionOverlapInfo& pnc_junction_overlap_info() const;
  ::cvte::hdmap::PNCJunctionOverlapInfo* release_pnc_junction_overlap_info();
  ::cvte::hdmap::PNCJunctionOverlapInfo* mutable_pnc_junction_overlap_info();
  void set_allocated_pnc_junction_overlap_info(::cvte::hdmap::PNCJunctionOverlapInfo* pnc_junction_overlap_info);

  // optional .cvte.hdmap.RSUOverlapInfo rsu_overlap_info = 13;
  bool has_rsu_overlap_info() const;
  void clear_rsu_overlap_info();
  static const int kRsuOverlapInfoFieldNumber = 13;
  private:
  const ::cvte::hdmap::RSUOverlapInfo& _internal_rsu_overlap_info() const;
  public:
  const ::cvte::hdmap::RSUOverlapInfo& rsu_overlap_info() const;
  ::cvte::hdmap::RSUOverlapInfo* release_rsu_overlap_info();
  ::cvte::hdmap::RSUOverlapInfo* mutable_rsu_overlap_info();
  void set_allocated_rsu_overlap_info(::cvte::hdmap::RSUOverlapInfo* rsu_overlap_info);

  void clear_overlap_info();
  OverlapInfoCase overlap_info_case() const;
  // @@protoc_insertion_point(class_scope:cvte.hdmap.ObjectOverlapInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_lane_overlap_info();
  void set_has_signal_overlap_info();
  void set_has_stop_sign_overlap_info();
  void set_has_crosswalk_overlap_info();
  void set_has_junction_overlap_info();
  void set_has_yield_sign_overlap_info();
  void set_has_clear_area_overlap_info();
  void set_has_speed_bump_overlap_info();
  void set_has_parking_space_overlap_info();
  void set_has_pnc_junction_overlap_info();
  void set_has_rsu_overlap_info();

  inline bool has_overlap_info() const;
  inline void clear_has_overlap_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::cvte::hdmap::Id* id_;
  union OverlapInfoUnion {
    OverlapInfoUnion() {}
    ::cvte::hdmap::LaneOverlapInfo* lane_overlap_info_;
    ::cvte::hdmap::SignalOverlapInfo* signal_overlap_info_;
    ::cvte::hdmap::StopSignOverlapInfo* stop_sign_overlap_info_;
    ::cvte::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info_;
    ::cvte::hdmap::JunctionOverlapInfo* junction_overlap_info_;
    ::cvte::hdmap::YieldOverlapInfo* yield_sign_overlap_info_;
    ::cvte::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info_;
    ::cvte::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info_;
    ::cvte::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info_;
    ::cvte::hdmap::PNCJunctionOverlapInfo* pnc_junction_overlap_info_;
    ::cvte::hdmap::RSUOverlapInfo* rsu_overlap_info_;
  } overlap_info_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Overlap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cvte.hdmap.Overlap) */ {
 public:
  Overlap();
  virtual ~Overlap();

  Overlap(const Overlap& from);

  inline Overlap& operator=(const Overlap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Overlap(Overlap&& from) noexcept
    : Overlap() {
    *this = ::std::move(from);
  }

  inline Overlap& operator=(Overlap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Overlap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Overlap* internal_default_instance() {
    return reinterpret_cast<const Overlap*>(
               &_Overlap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Overlap* other);
  friend void swap(Overlap& a, Overlap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Overlap* New() const final {
    return CreateMaybeMessage<Overlap>(NULL);
  }

  Overlap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Overlap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Overlap& from);
  void MergeFrom(const Overlap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Overlap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cvte.hdmap.ObjectOverlapInfo object = 2;
  int object_size() const;
  void clear_object();
  static const int kObjectFieldNumber = 2;
  ::cvte::hdmap::ObjectOverlapInfo* mutable_object(int index);
  ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::ObjectOverlapInfo >*
      mutable_object();
  const ::cvte::hdmap::ObjectOverlapInfo& object(int index) const;
  ::cvte::hdmap::ObjectOverlapInfo* add_object();
  const ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::ObjectOverlapInfo >&
      object() const;

  // repeated .cvte.hdmap.RegionOverlapInfo region_overlap = 3;
  int region_overlap_size() const;
  void clear_region_overlap();
  static const int kRegionOverlapFieldNumber = 3;
  ::cvte::hdmap::RegionOverlapInfo* mutable_region_overlap(int index);
  ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::RegionOverlapInfo >*
      mutable_region_overlap();
  const ::cvte::hdmap::RegionOverlapInfo& region_overlap(int index) const;
  ::cvte::hdmap::RegionOverlapInfo* add_region_overlap();
  const ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::RegionOverlapInfo >&
      region_overlap() const;

  // optional .cvte.hdmap.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  private:
  const ::cvte::hdmap::Id& _internal_id() const;
  public:
  const ::cvte::hdmap::Id& id() const;
  ::cvte::hdmap::Id* release_id();
  ::cvte::hdmap::Id* mutable_id();
  void set_allocated_id(::cvte::hdmap::Id* id);

  // @@protoc_insertion_point(class_scope:cvte.hdmap.Overlap)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::ObjectOverlapInfo > object_;
  ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::RegionOverlapInfo > region_overlap_;
  ::cvte::hdmap::Id* id_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LaneOverlapInfo

// optional double start_s = 1;
inline bool LaneOverlapInfo::has_start_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneOverlapInfo::set_has_start_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneOverlapInfo::clear_has_start_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneOverlapInfo::clear_start_s() {
  start_s_ = 0;
  clear_has_start_s();
}
inline double LaneOverlapInfo::start_s() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.LaneOverlapInfo.start_s)
  return start_s_;
}
inline void LaneOverlapInfo::set_start_s(double value) {
  set_has_start_s();
  start_s_ = value;
  // @@protoc_insertion_point(field_set:cvte.hdmap.LaneOverlapInfo.start_s)
}

// optional double end_s = 2;
inline bool LaneOverlapInfo::has_end_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneOverlapInfo::set_has_end_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneOverlapInfo::clear_has_end_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneOverlapInfo::clear_end_s() {
  end_s_ = 0;
  clear_has_end_s();
}
inline double LaneOverlapInfo::end_s() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.LaneOverlapInfo.end_s)
  return end_s_;
}
inline void LaneOverlapInfo::set_end_s(double value) {
  set_has_end_s();
  end_s_ = value;
  // @@protoc_insertion_point(field_set:cvte.hdmap.LaneOverlapInfo.end_s)
}

// optional bool is_merge = 3;
inline bool LaneOverlapInfo::has_is_merge() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneOverlapInfo::set_has_is_merge() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneOverlapInfo::clear_has_is_merge() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaneOverlapInfo::clear_is_merge() {
  is_merge_ = false;
  clear_has_is_merge();
}
inline bool LaneOverlapInfo::is_merge() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.LaneOverlapInfo.is_merge)
  return is_merge_;
}
inline void LaneOverlapInfo::set_is_merge(bool value) {
  set_has_is_merge();
  is_merge_ = value;
  // @@protoc_insertion_point(field_set:cvte.hdmap.LaneOverlapInfo.is_merge)
}

// optional .cvte.hdmap.Id region_overlap_id = 4;
inline bool LaneOverlapInfo::has_region_overlap_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneOverlapInfo::set_has_region_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneOverlapInfo::clear_has_region_overlap_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::cvte::hdmap::Id& LaneOverlapInfo::_internal_region_overlap_id() const {
  return *region_overlap_id_;
}
inline const ::cvte::hdmap::Id& LaneOverlapInfo::region_overlap_id() const {
  const ::cvte::hdmap::Id* p = region_overlap_id_;
  // @@protoc_insertion_point(field_get:cvte.hdmap.LaneOverlapInfo.region_overlap_id)
  return p != NULL ? *p : *reinterpret_cast<const ::cvte::hdmap::Id*>(
      &::cvte::hdmap::_Id_default_instance_);
}
inline ::cvte::hdmap::Id* LaneOverlapInfo::release_region_overlap_id() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.LaneOverlapInfo.region_overlap_id)
  clear_has_region_overlap_id();
  ::cvte::hdmap::Id* temp = region_overlap_id_;
  region_overlap_id_ = NULL;
  return temp;
}
inline ::cvte::hdmap::Id* LaneOverlapInfo::mutable_region_overlap_id() {
  set_has_region_overlap_id();
  if (region_overlap_id_ == NULL) {
    auto* p = CreateMaybeMessage<::cvte::hdmap::Id>(GetArenaNoVirtual());
    region_overlap_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.LaneOverlapInfo.region_overlap_id)
  return region_overlap_id_;
}
inline void LaneOverlapInfo::set_allocated_region_overlap_id(::cvte::hdmap::Id* region_overlap_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_overlap_id_);
  }
  if (region_overlap_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_overlap_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_overlap_id, submessage_arena);
    }
    set_has_region_overlap_id();
  } else {
    clear_has_region_overlap_id();
  }
  region_overlap_id_ = region_overlap_id;
  // @@protoc_insertion_point(field_set_allocated:cvte.hdmap.LaneOverlapInfo.region_overlap_id)
}

// -------------------------------------------------------------------

// SignalOverlapInfo

// -------------------------------------------------------------------

// StopSignOverlapInfo

// -------------------------------------------------------------------

// CrosswalkOverlapInfo

// optional .cvte.hdmap.Id region_overlap_id = 1;
inline bool CrosswalkOverlapInfo::has_region_overlap_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrosswalkOverlapInfo::set_has_region_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrosswalkOverlapInfo::clear_has_region_overlap_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::cvte::hdmap::Id& CrosswalkOverlapInfo::_internal_region_overlap_id() const {
  return *region_overlap_id_;
}
inline const ::cvte::hdmap::Id& CrosswalkOverlapInfo::region_overlap_id() const {
  const ::cvte::hdmap::Id* p = region_overlap_id_;
  // @@protoc_insertion_point(field_get:cvte.hdmap.CrosswalkOverlapInfo.region_overlap_id)
  return p != NULL ? *p : *reinterpret_cast<const ::cvte::hdmap::Id*>(
      &::cvte::hdmap::_Id_default_instance_);
}
inline ::cvte::hdmap::Id* CrosswalkOverlapInfo::release_region_overlap_id() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.CrosswalkOverlapInfo.region_overlap_id)
  clear_has_region_overlap_id();
  ::cvte::hdmap::Id* temp = region_overlap_id_;
  region_overlap_id_ = NULL;
  return temp;
}
inline ::cvte::hdmap::Id* CrosswalkOverlapInfo::mutable_region_overlap_id() {
  set_has_region_overlap_id();
  if (region_overlap_id_ == NULL) {
    auto* p = CreateMaybeMessage<::cvte::hdmap::Id>(GetArenaNoVirtual());
    region_overlap_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.CrosswalkOverlapInfo.region_overlap_id)
  return region_overlap_id_;
}
inline void CrosswalkOverlapInfo::set_allocated_region_overlap_id(::cvte::hdmap::Id* region_overlap_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_overlap_id_);
  }
  if (region_overlap_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_overlap_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_overlap_id, submessage_arena);
    }
    set_has_region_overlap_id();
  } else {
    clear_has_region_overlap_id();
  }
  region_overlap_id_ = region_overlap_id;
  // @@protoc_insertion_point(field_set_allocated:cvte.hdmap.CrosswalkOverlapInfo.region_overlap_id)
}

// -------------------------------------------------------------------

// JunctionOverlapInfo

// -------------------------------------------------------------------

// YieldOverlapInfo

// -------------------------------------------------------------------

// ClearAreaOverlapInfo

// -------------------------------------------------------------------

// SpeedBumpOverlapInfo

// -------------------------------------------------------------------

// ParkingSpaceOverlapInfo

// -------------------------------------------------------------------

// PNCJunctionOverlapInfo

// -------------------------------------------------------------------

// RSUOverlapInfo

// -------------------------------------------------------------------

// RegionOverlapInfo

// optional .cvte.hdmap.Id id = 1;
inline bool RegionOverlapInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionOverlapInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionOverlapInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::cvte::hdmap::Id& RegionOverlapInfo::_internal_id() const {
  return *id_;
}
inline const ::cvte::hdmap::Id& RegionOverlapInfo::id() const {
  const ::cvte::hdmap::Id* p = id_;
  // @@protoc_insertion_point(field_get:cvte.hdmap.RegionOverlapInfo.id)
  return p != NULL ? *p : *reinterpret_cast<const ::cvte::hdmap::Id*>(
      &::cvte::hdmap::_Id_default_instance_);
}
inline ::cvte::hdmap::Id* RegionOverlapInfo::release_id() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.RegionOverlapInfo.id)
  clear_has_id();
  ::cvte::hdmap::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::cvte::hdmap::Id* RegionOverlapInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    auto* p = CreateMaybeMessage<::cvte::hdmap::Id>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.RegionOverlapInfo.id)
  return id_;
}
inline void RegionOverlapInfo::set_allocated_id(::cvte::hdmap::Id* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:cvte.hdmap.RegionOverlapInfo.id)
}

// repeated .cvte.hdmap.Polygon polygon = 2;
inline int RegionOverlapInfo::polygon_size() const {
  return polygon_.size();
}
inline ::cvte::hdmap::Polygon* RegionOverlapInfo::mutable_polygon(int index) {
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.RegionOverlapInfo.polygon)
  return polygon_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::Polygon >*
RegionOverlapInfo::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable_list:cvte.hdmap.RegionOverlapInfo.polygon)
  return &polygon_;
}
inline const ::cvte::hdmap::Polygon& RegionOverlapInfo::polygon(int index) const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.RegionOverlapInfo.polygon)
  return polygon_.Get(index);
}
inline ::cvte::hdmap::Polygon* RegionOverlapInfo::add_polygon() {
  // @@protoc_insertion_point(field_add:cvte.hdmap.RegionOverlapInfo.polygon)
  return polygon_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::Polygon >&
RegionOverlapInfo::polygon() const {
  // @@protoc_insertion_point(field_list:cvte.hdmap.RegionOverlapInfo.polygon)
  return polygon_;
}

// -------------------------------------------------------------------

// ObjectOverlapInfo

// optional .cvte.hdmap.Id id = 1;
inline bool ObjectOverlapInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectOverlapInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectOverlapInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::cvte::hdmap::Id& ObjectOverlapInfo::_internal_id() const {
  return *id_;
}
inline const ::cvte::hdmap::Id& ObjectOverlapInfo::id() const {
  const ::cvte::hdmap::Id* p = id_;
  // @@protoc_insertion_point(field_get:cvte.hdmap.ObjectOverlapInfo.id)
  return p != NULL ? *p : *reinterpret_cast<const ::cvte::hdmap::Id*>(
      &::cvte::hdmap::_Id_default_instance_);
}
inline ::cvte::hdmap::Id* ObjectOverlapInfo::release_id() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.ObjectOverlapInfo.id)
  clear_has_id();
  ::cvte::hdmap::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::cvte::hdmap::Id* ObjectOverlapInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    auto* p = CreateMaybeMessage<::cvte::hdmap::Id>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.ObjectOverlapInfo.id)
  return id_;
}
inline void ObjectOverlapInfo::set_allocated_id(::cvte::hdmap::Id* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:cvte.hdmap.ObjectOverlapInfo.id)
}

// optional .cvte.hdmap.LaneOverlapInfo lane_overlap_info = 3;
inline bool ObjectOverlapInfo::has_lane_overlap_info() const {
  return overlap_info_case() == kLaneOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_lane_overlap_info() {
  _oneof_case_[0] = kLaneOverlapInfo;
}
inline void ObjectOverlapInfo::clear_lane_overlap_info() {
  if (has_lane_overlap_info()) {
    delete overlap_info_.lane_overlap_info_;
    clear_has_overlap_info();
  }
}
inline const ::cvte::hdmap::LaneOverlapInfo& ObjectOverlapInfo::_internal_lane_overlap_info() const {
  return *overlap_info_.lane_overlap_info_;
}
inline ::cvte::hdmap::LaneOverlapInfo* ObjectOverlapInfo::release_lane_overlap_info() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.ObjectOverlapInfo.lane_overlap_info)
  if (has_lane_overlap_info()) {
    clear_has_overlap_info();
      ::cvte::hdmap::LaneOverlapInfo* temp = overlap_info_.lane_overlap_info_;
    overlap_info_.lane_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cvte::hdmap::LaneOverlapInfo& ObjectOverlapInfo::lane_overlap_info() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.ObjectOverlapInfo.lane_overlap_info)
  return has_lane_overlap_info()
      ? *overlap_info_.lane_overlap_info_
      : *reinterpret_cast< ::cvte::hdmap::LaneOverlapInfo*>(&::cvte::hdmap::_LaneOverlapInfo_default_instance_);
}
inline ::cvte::hdmap::LaneOverlapInfo* ObjectOverlapInfo::mutable_lane_overlap_info() {
  if (!has_lane_overlap_info()) {
    clear_overlap_info();
    set_has_lane_overlap_info();
    overlap_info_.lane_overlap_info_ = CreateMaybeMessage< ::cvte::hdmap::LaneOverlapInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.ObjectOverlapInfo.lane_overlap_info)
  return overlap_info_.lane_overlap_info_;
}

// optional .cvte.hdmap.SignalOverlapInfo signal_overlap_info = 4;
inline bool ObjectOverlapInfo::has_signal_overlap_info() const {
  return overlap_info_case() == kSignalOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_signal_overlap_info() {
  _oneof_case_[0] = kSignalOverlapInfo;
}
inline void ObjectOverlapInfo::clear_signal_overlap_info() {
  if (has_signal_overlap_info()) {
    delete overlap_info_.signal_overlap_info_;
    clear_has_overlap_info();
  }
}
inline const ::cvte::hdmap::SignalOverlapInfo& ObjectOverlapInfo::_internal_signal_overlap_info() const {
  return *overlap_info_.signal_overlap_info_;
}
inline ::cvte::hdmap::SignalOverlapInfo* ObjectOverlapInfo::release_signal_overlap_info() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.ObjectOverlapInfo.signal_overlap_info)
  if (has_signal_overlap_info()) {
    clear_has_overlap_info();
      ::cvte::hdmap::SignalOverlapInfo* temp = overlap_info_.signal_overlap_info_;
    overlap_info_.signal_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cvte::hdmap::SignalOverlapInfo& ObjectOverlapInfo::signal_overlap_info() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.ObjectOverlapInfo.signal_overlap_info)
  return has_signal_overlap_info()
      ? *overlap_info_.signal_overlap_info_
      : *reinterpret_cast< ::cvte::hdmap::SignalOverlapInfo*>(&::cvte::hdmap::_SignalOverlapInfo_default_instance_);
}
inline ::cvte::hdmap::SignalOverlapInfo* ObjectOverlapInfo::mutable_signal_overlap_info() {
  if (!has_signal_overlap_info()) {
    clear_overlap_info();
    set_has_signal_overlap_info();
    overlap_info_.signal_overlap_info_ = CreateMaybeMessage< ::cvte::hdmap::SignalOverlapInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.ObjectOverlapInfo.signal_overlap_info)
  return overlap_info_.signal_overlap_info_;
}

// optional .cvte.hdmap.StopSignOverlapInfo stop_sign_overlap_info = 5;
inline bool ObjectOverlapInfo::has_stop_sign_overlap_info() const {
  return overlap_info_case() == kStopSignOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_stop_sign_overlap_info() {
  _oneof_case_[0] = kStopSignOverlapInfo;
}
inline void ObjectOverlapInfo::clear_stop_sign_overlap_info() {
  if (has_stop_sign_overlap_info()) {
    delete overlap_info_.stop_sign_overlap_info_;
    clear_has_overlap_info();
  }
}
inline const ::cvte::hdmap::StopSignOverlapInfo& ObjectOverlapInfo::_internal_stop_sign_overlap_info() const {
  return *overlap_info_.stop_sign_overlap_info_;
}
inline ::cvte::hdmap::StopSignOverlapInfo* ObjectOverlapInfo::release_stop_sign_overlap_info() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  if (has_stop_sign_overlap_info()) {
    clear_has_overlap_info();
      ::cvte::hdmap::StopSignOverlapInfo* temp = overlap_info_.stop_sign_overlap_info_;
    overlap_info_.stop_sign_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cvte::hdmap::StopSignOverlapInfo& ObjectOverlapInfo::stop_sign_overlap_info() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  return has_stop_sign_overlap_info()
      ? *overlap_info_.stop_sign_overlap_info_
      : *reinterpret_cast< ::cvte::hdmap::StopSignOverlapInfo*>(&::cvte::hdmap::_StopSignOverlapInfo_default_instance_);
}
inline ::cvte::hdmap::StopSignOverlapInfo* ObjectOverlapInfo::mutable_stop_sign_overlap_info() {
  if (!has_stop_sign_overlap_info()) {
    clear_overlap_info();
    set_has_stop_sign_overlap_info();
    overlap_info_.stop_sign_overlap_info_ = CreateMaybeMessage< ::cvte::hdmap::StopSignOverlapInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  return overlap_info_.stop_sign_overlap_info_;
}

// optional .cvte.hdmap.CrosswalkOverlapInfo crosswalk_overlap_info = 6;
inline bool ObjectOverlapInfo::has_crosswalk_overlap_info() const {
  return overlap_info_case() == kCrosswalkOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_crosswalk_overlap_info() {
  _oneof_case_[0] = kCrosswalkOverlapInfo;
}
inline void ObjectOverlapInfo::clear_crosswalk_overlap_info() {
  if (has_crosswalk_overlap_info()) {
    delete overlap_info_.crosswalk_overlap_info_;
    clear_has_overlap_info();
  }
}
inline const ::cvte::hdmap::CrosswalkOverlapInfo& ObjectOverlapInfo::_internal_crosswalk_overlap_info() const {
  return *overlap_info_.crosswalk_overlap_info_;
}
inline ::cvte::hdmap::CrosswalkOverlapInfo* ObjectOverlapInfo::release_crosswalk_overlap_info() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  if (has_crosswalk_overlap_info()) {
    clear_has_overlap_info();
      ::cvte::hdmap::CrosswalkOverlapInfo* temp = overlap_info_.crosswalk_overlap_info_;
    overlap_info_.crosswalk_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cvte::hdmap::CrosswalkOverlapInfo& ObjectOverlapInfo::crosswalk_overlap_info() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  return has_crosswalk_overlap_info()
      ? *overlap_info_.crosswalk_overlap_info_
      : *reinterpret_cast< ::cvte::hdmap::CrosswalkOverlapInfo*>(&::cvte::hdmap::_CrosswalkOverlapInfo_default_instance_);
}
inline ::cvte::hdmap::CrosswalkOverlapInfo* ObjectOverlapInfo::mutable_crosswalk_overlap_info() {
  if (!has_crosswalk_overlap_info()) {
    clear_overlap_info();
    set_has_crosswalk_overlap_info();
    overlap_info_.crosswalk_overlap_info_ = CreateMaybeMessage< ::cvte::hdmap::CrosswalkOverlapInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  return overlap_info_.crosswalk_overlap_info_;
}

// optional .cvte.hdmap.JunctionOverlapInfo junction_overlap_info = 7;
inline bool ObjectOverlapInfo::has_junction_overlap_info() const {
  return overlap_info_case() == kJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_junction_overlap_info() {
  _oneof_case_[0] = kJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::clear_junction_overlap_info() {
  if (has_junction_overlap_info()) {
    delete overlap_info_.junction_overlap_info_;
    clear_has_overlap_info();
  }
}
inline const ::cvte::hdmap::JunctionOverlapInfo& ObjectOverlapInfo::_internal_junction_overlap_info() const {
  return *overlap_info_.junction_overlap_info_;
}
inline ::cvte::hdmap::JunctionOverlapInfo* ObjectOverlapInfo::release_junction_overlap_info() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.ObjectOverlapInfo.junction_overlap_info)
  if (has_junction_overlap_info()) {
    clear_has_overlap_info();
      ::cvte::hdmap::JunctionOverlapInfo* temp = overlap_info_.junction_overlap_info_;
    overlap_info_.junction_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cvte::hdmap::JunctionOverlapInfo& ObjectOverlapInfo::junction_overlap_info() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.ObjectOverlapInfo.junction_overlap_info)
  return has_junction_overlap_info()
      ? *overlap_info_.junction_overlap_info_
      : *reinterpret_cast< ::cvte::hdmap::JunctionOverlapInfo*>(&::cvte::hdmap::_JunctionOverlapInfo_default_instance_);
}
inline ::cvte::hdmap::JunctionOverlapInfo* ObjectOverlapInfo::mutable_junction_overlap_info() {
  if (!has_junction_overlap_info()) {
    clear_overlap_info();
    set_has_junction_overlap_info();
    overlap_info_.junction_overlap_info_ = CreateMaybeMessage< ::cvte::hdmap::JunctionOverlapInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.ObjectOverlapInfo.junction_overlap_info)
  return overlap_info_.junction_overlap_info_;
}

// optional .cvte.hdmap.YieldOverlapInfo yield_sign_overlap_info = 8;
inline bool ObjectOverlapInfo::has_yield_sign_overlap_info() const {
  return overlap_info_case() == kYieldSignOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_yield_sign_overlap_info() {
  _oneof_case_[0] = kYieldSignOverlapInfo;
}
inline void ObjectOverlapInfo::clear_yield_sign_overlap_info() {
  if (has_yield_sign_overlap_info()) {
    delete overlap_info_.yield_sign_overlap_info_;
    clear_has_overlap_info();
  }
}
inline const ::cvte::hdmap::YieldOverlapInfo& ObjectOverlapInfo::_internal_yield_sign_overlap_info() const {
  return *overlap_info_.yield_sign_overlap_info_;
}
inline ::cvte::hdmap::YieldOverlapInfo* ObjectOverlapInfo::release_yield_sign_overlap_info() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  if (has_yield_sign_overlap_info()) {
    clear_has_overlap_info();
      ::cvte::hdmap::YieldOverlapInfo* temp = overlap_info_.yield_sign_overlap_info_;
    overlap_info_.yield_sign_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cvte::hdmap::YieldOverlapInfo& ObjectOverlapInfo::yield_sign_overlap_info() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  return has_yield_sign_overlap_info()
      ? *overlap_info_.yield_sign_overlap_info_
      : *reinterpret_cast< ::cvte::hdmap::YieldOverlapInfo*>(&::cvte::hdmap::_YieldOverlapInfo_default_instance_);
}
inline ::cvte::hdmap::YieldOverlapInfo* ObjectOverlapInfo::mutable_yield_sign_overlap_info() {
  if (!has_yield_sign_overlap_info()) {
    clear_overlap_info();
    set_has_yield_sign_overlap_info();
    overlap_info_.yield_sign_overlap_info_ = CreateMaybeMessage< ::cvte::hdmap::YieldOverlapInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  return overlap_info_.yield_sign_overlap_info_;
}

// optional .cvte.hdmap.ClearAreaOverlapInfo clear_area_overlap_info = 9;
inline bool ObjectOverlapInfo::has_clear_area_overlap_info() const {
  return overlap_info_case() == kClearAreaOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_clear_area_overlap_info() {
  _oneof_case_[0] = kClearAreaOverlapInfo;
}
inline void ObjectOverlapInfo::clear_clear_area_overlap_info() {
  if (has_clear_area_overlap_info()) {
    delete overlap_info_.clear_area_overlap_info_;
    clear_has_overlap_info();
  }
}
inline const ::cvte::hdmap::ClearAreaOverlapInfo& ObjectOverlapInfo::_internal_clear_area_overlap_info() const {
  return *overlap_info_.clear_area_overlap_info_;
}
inline ::cvte::hdmap::ClearAreaOverlapInfo* ObjectOverlapInfo::release_clear_area_overlap_info() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  if (has_clear_area_overlap_info()) {
    clear_has_overlap_info();
      ::cvte::hdmap::ClearAreaOverlapInfo* temp = overlap_info_.clear_area_overlap_info_;
    overlap_info_.clear_area_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cvte::hdmap::ClearAreaOverlapInfo& ObjectOverlapInfo::clear_area_overlap_info() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  return has_clear_area_overlap_info()
      ? *overlap_info_.clear_area_overlap_info_
      : *reinterpret_cast< ::cvte::hdmap::ClearAreaOverlapInfo*>(&::cvte::hdmap::_ClearAreaOverlapInfo_default_instance_);
}
inline ::cvte::hdmap::ClearAreaOverlapInfo* ObjectOverlapInfo::mutable_clear_area_overlap_info() {
  if (!has_clear_area_overlap_info()) {
    clear_overlap_info();
    set_has_clear_area_overlap_info();
    overlap_info_.clear_area_overlap_info_ = CreateMaybeMessage< ::cvte::hdmap::ClearAreaOverlapInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  return overlap_info_.clear_area_overlap_info_;
}

// optional .cvte.hdmap.SpeedBumpOverlapInfo speed_bump_overlap_info = 10;
inline bool ObjectOverlapInfo::has_speed_bump_overlap_info() const {
  return overlap_info_case() == kSpeedBumpOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_speed_bump_overlap_info() {
  _oneof_case_[0] = kSpeedBumpOverlapInfo;
}
inline void ObjectOverlapInfo::clear_speed_bump_overlap_info() {
  if (has_speed_bump_overlap_info()) {
    delete overlap_info_.speed_bump_overlap_info_;
    clear_has_overlap_info();
  }
}
inline const ::cvte::hdmap::SpeedBumpOverlapInfo& ObjectOverlapInfo::_internal_speed_bump_overlap_info() const {
  return *overlap_info_.speed_bump_overlap_info_;
}
inline ::cvte::hdmap::SpeedBumpOverlapInfo* ObjectOverlapInfo::release_speed_bump_overlap_info() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  if (has_speed_bump_overlap_info()) {
    clear_has_overlap_info();
      ::cvte::hdmap::SpeedBumpOverlapInfo* temp = overlap_info_.speed_bump_overlap_info_;
    overlap_info_.speed_bump_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cvte::hdmap::SpeedBumpOverlapInfo& ObjectOverlapInfo::speed_bump_overlap_info() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  return has_speed_bump_overlap_info()
      ? *overlap_info_.speed_bump_overlap_info_
      : *reinterpret_cast< ::cvte::hdmap::SpeedBumpOverlapInfo*>(&::cvte::hdmap::_SpeedBumpOverlapInfo_default_instance_);
}
inline ::cvte::hdmap::SpeedBumpOverlapInfo* ObjectOverlapInfo::mutable_speed_bump_overlap_info() {
  if (!has_speed_bump_overlap_info()) {
    clear_overlap_info();
    set_has_speed_bump_overlap_info();
    overlap_info_.speed_bump_overlap_info_ = CreateMaybeMessage< ::cvte::hdmap::SpeedBumpOverlapInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  return overlap_info_.speed_bump_overlap_info_;
}

// optional .cvte.hdmap.ParkingSpaceOverlapInfo parking_space_overlap_info = 11;
inline bool ObjectOverlapInfo::has_parking_space_overlap_info() const {
  return overlap_info_case() == kParkingSpaceOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_parking_space_overlap_info() {
  _oneof_case_[0] = kParkingSpaceOverlapInfo;
}
inline void ObjectOverlapInfo::clear_parking_space_overlap_info() {
  if (has_parking_space_overlap_info()) {
    delete overlap_info_.parking_space_overlap_info_;
    clear_has_overlap_info();
  }
}
inline const ::cvte::hdmap::ParkingSpaceOverlapInfo& ObjectOverlapInfo::_internal_parking_space_overlap_info() const {
  return *overlap_info_.parking_space_overlap_info_;
}
inline ::cvte::hdmap::ParkingSpaceOverlapInfo* ObjectOverlapInfo::release_parking_space_overlap_info() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  if (has_parking_space_overlap_info()) {
    clear_has_overlap_info();
      ::cvte::hdmap::ParkingSpaceOverlapInfo* temp = overlap_info_.parking_space_overlap_info_;
    overlap_info_.parking_space_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cvte::hdmap::ParkingSpaceOverlapInfo& ObjectOverlapInfo::parking_space_overlap_info() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  return has_parking_space_overlap_info()
      ? *overlap_info_.parking_space_overlap_info_
      : *reinterpret_cast< ::cvte::hdmap::ParkingSpaceOverlapInfo*>(&::cvte::hdmap::_ParkingSpaceOverlapInfo_default_instance_);
}
inline ::cvte::hdmap::ParkingSpaceOverlapInfo* ObjectOverlapInfo::mutable_parking_space_overlap_info() {
  if (!has_parking_space_overlap_info()) {
    clear_overlap_info();
    set_has_parking_space_overlap_info();
    overlap_info_.parking_space_overlap_info_ = CreateMaybeMessage< ::cvte::hdmap::ParkingSpaceOverlapInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  return overlap_info_.parking_space_overlap_info_;
}

// optional .cvte.hdmap.PNCJunctionOverlapInfo pnc_junction_overlap_info = 12;
inline bool ObjectOverlapInfo::has_pnc_junction_overlap_info() const {
  return overlap_info_case() == kPncJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_pnc_junction_overlap_info() {
  _oneof_case_[0] = kPncJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::clear_pnc_junction_overlap_info() {
  if (has_pnc_junction_overlap_info()) {
    delete overlap_info_.pnc_junction_overlap_info_;
    clear_has_overlap_info();
  }
}
inline const ::cvte::hdmap::PNCJunctionOverlapInfo& ObjectOverlapInfo::_internal_pnc_junction_overlap_info() const {
  return *overlap_info_.pnc_junction_overlap_info_;
}
inline ::cvte::hdmap::PNCJunctionOverlapInfo* ObjectOverlapInfo::release_pnc_junction_overlap_info() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.ObjectOverlapInfo.pnc_junction_overlap_info)
  if (has_pnc_junction_overlap_info()) {
    clear_has_overlap_info();
      ::cvte::hdmap::PNCJunctionOverlapInfo* temp = overlap_info_.pnc_junction_overlap_info_;
    overlap_info_.pnc_junction_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cvte::hdmap::PNCJunctionOverlapInfo& ObjectOverlapInfo::pnc_junction_overlap_info() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.ObjectOverlapInfo.pnc_junction_overlap_info)
  return has_pnc_junction_overlap_info()
      ? *overlap_info_.pnc_junction_overlap_info_
      : *reinterpret_cast< ::cvte::hdmap::PNCJunctionOverlapInfo*>(&::cvte::hdmap::_PNCJunctionOverlapInfo_default_instance_);
}
inline ::cvte::hdmap::PNCJunctionOverlapInfo* ObjectOverlapInfo::mutable_pnc_junction_overlap_info() {
  if (!has_pnc_junction_overlap_info()) {
    clear_overlap_info();
    set_has_pnc_junction_overlap_info();
    overlap_info_.pnc_junction_overlap_info_ = CreateMaybeMessage< ::cvte::hdmap::PNCJunctionOverlapInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.ObjectOverlapInfo.pnc_junction_overlap_info)
  return overlap_info_.pnc_junction_overlap_info_;
}

// optional .cvte.hdmap.RSUOverlapInfo rsu_overlap_info = 13;
inline bool ObjectOverlapInfo::has_rsu_overlap_info() const {
  return overlap_info_case() == kRsuOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_rsu_overlap_info() {
  _oneof_case_[0] = kRsuOverlapInfo;
}
inline void ObjectOverlapInfo::clear_rsu_overlap_info() {
  if (has_rsu_overlap_info()) {
    delete overlap_info_.rsu_overlap_info_;
    clear_has_overlap_info();
  }
}
inline const ::cvte::hdmap::RSUOverlapInfo& ObjectOverlapInfo::_internal_rsu_overlap_info() const {
  return *overlap_info_.rsu_overlap_info_;
}
inline ::cvte::hdmap::RSUOverlapInfo* ObjectOverlapInfo::release_rsu_overlap_info() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.ObjectOverlapInfo.rsu_overlap_info)
  if (has_rsu_overlap_info()) {
    clear_has_overlap_info();
      ::cvte::hdmap::RSUOverlapInfo* temp = overlap_info_.rsu_overlap_info_;
    overlap_info_.rsu_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cvte::hdmap::RSUOverlapInfo& ObjectOverlapInfo::rsu_overlap_info() const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.ObjectOverlapInfo.rsu_overlap_info)
  return has_rsu_overlap_info()
      ? *overlap_info_.rsu_overlap_info_
      : *reinterpret_cast< ::cvte::hdmap::RSUOverlapInfo*>(&::cvte::hdmap::_RSUOverlapInfo_default_instance_);
}
inline ::cvte::hdmap::RSUOverlapInfo* ObjectOverlapInfo::mutable_rsu_overlap_info() {
  if (!has_rsu_overlap_info()) {
    clear_overlap_info();
    set_has_rsu_overlap_info();
    overlap_info_.rsu_overlap_info_ = CreateMaybeMessage< ::cvte::hdmap::RSUOverlapInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.ObjectOverlapInfo.rsu_overlap_info)
  return overlap_info_.rsu_overlap_info_;
}

inline bool ObjectOverlapInfo::has_overlap_info() const {
  return overlap_info_case() != OVERLAP_INFO_NOT_SET;
}
inline void ObjectOverlapInfo::clear_has_overlap_info() {
  _oneof_case_[0] = OVERLAP_INFO_NOT_SET;
}
inline ObjectOverlapInfo::OverlapInfoCase ObjectOverlapInfo::overlap_info_case() const {
  return ObjectOverlapInfo::OverlapInfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Overlap

// optional .cvte.hdmap.Id id = 1;
inline bool Overlap::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Overlap::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Overlap::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::cvte::hdmap::Id& Overlap::_internal_id() const {
  return *id_;
}
inline const ::cvte::hdmap::Id& Overlap::id() const {
  const ::cvte::hdmap::Id* p = id_;
  // @@protoc_insertion_point(field_get:cvte.hdmap.Overlap.id)
  return p != NULL ? *p : *reinterpret_cast<const ::cvte::hdmap::Id*>(
      &::cvte::hdmap::_Id_default_instance_);
}
inline ::cvte::hdmap::Id* Overlap::release_id() {
  // @@protoc_insertion_point(field_release:cvte.hdmap.Overlap.id)
  clear_has_id();
  ::cvte::hdmap::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::cvte::hdmap::Id* Overlap::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    auto* p = CreateMaybeMessage<::cvte::hdmap::Id>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.Overlap.id)
  return id_;
}
inline void Overlap::set_allocated_id(::cvte::hdmap::Id* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:cvte.hdmap.Overlap.id)
}

// repeated .cvte.hdmap.ObjectOverlapInfo object = 2;
inline int Overlap::object_size() const {
  return object_.size();
}
inline void Overlap::clear_object() {
  object_.Clear();
}
inline ::cvte::hdmap::ObjectOverlapInfo* Overlap::mutable_object(int index) {
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.Overlap.object)
  return object_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::ObjectOverlapInfo >*
Overlap::mutable_object() {
  // @@protoc_insertion_point(field_mutable_list:cvte.hdmap.Overlap.object)
  return &object_;
}
inline const ::cvte::hdmap::ObjectOverlapInfo& Overlap::object(int index) const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.Overlap.object)
  return object_.Get(index);
}
inline ::cvte::hdmap::ObjectOverlapInfo* Overlap::add_object() {
  // @@protoc_insertion_point(field_add:cvte.hdmap.Overlap.object)
  return object_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::ObjectOverlapInfo >&
Overlap::object() const {
  // @@protoc_insertion_point(field_list:cvte.hdmap.Overlap.object)
  return object_;
}

// repeated .cvte.hdmap.RegionOverlapInfo region_overlap = 3;
inline int Overlap::region_overlap_size() const {
  return region_overlap_.size();
}
inline void Overlap::clear_region_overlap() {
  region_overlap_.Clear();
}
inline ::cvte::hdmap::RegionOverlapInfo* Overlap::mutable_region_overlap(int index) {
  // @@protoc_insertion_point(field_mutable:cvte.hdmap.Overlap.region_overlap)
  return region_overlap_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::RegionOverlapInfo >*
Overlap::mutable_region_overlap() {
  // @@protoc_insertion_point(field_mutable_list:cvte.hdmap.Overlap.region_overlap)
  return &region_overlap_;
}
inline const ::cvte::hdmap::RegionOverlapInfo& Overlap::region_overlap(int index) const {
  // @@protoc_insertion_point(field_get:cvte.hdmap.Overlap.region_overlap)
  return region_overlap_.Get(index);
}
inline ::cvte::hdmap::RegionOverlapInfo* Overlap::add_region_overlap() {
  // @@protoc_insertion_point(field_add:cvte.hdmap.Overlap.region_overlap)
  return region_overlap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cvte::hdmap::RegionOverlapInfo >&
Overlap::region_overlap() const {
  // @@protoc_insertion_point(field_list:cvte.hdmap.Overlap.region_overlap)
  return region_overlap_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hdmap
}  // namespace cvte

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_map_5foverlap_2eproto
